---
title: "调度策略和任务分配"
date: 2025-11-23T23:02:35+08:00
description : "Go语言调度策略"
image : "/img/posts/2025/20251123/stealing.jpg"
tags: ["go", "goroutine", "thread", "processor", "scheduler"]
---

# Work stealing 调度策略概念

每个 M 都会优先从自己绑定的 P 的本地队列中获取任务。如果本地队列为空则会从其他 P 的队列中获取任务。如果从其他队列也获取不到任务还可以从全局队列获取任务。通过任务的“窃取”来保证 CPU 的利用率。

## 对比线程池

|特性|Work stealing|传统线程池|
|:---|:---|:---|
|队列数量|每个 P 有本地队列 + 全局队列|单全局队列（少数实现有队列）|
|任务分配|本地有限->steal->全局|全局队列拉取|
|锁竞争|较少（本地队列多为无锁的 dequeue）|较多，全局队列争用|
|CPU 利用率|高，M 会 steal 防止闲置|较低，线程可能等待全局队列|
|适合场景|短任务、高并发、轻量的G|长任务、固定任务量|
|响应延迟|低，本地队列优先|较高，全局队列可能阻塞|
|扩展性|好，增加 P/M 容易|受全局队列瓶颈限制|

# 上下文切换

|组件|描述|是否CPU实体|
|:---|:---|:---|
|G|goroutine，包含函数栈、调度状态|非实体，可大量创建|
|M|machine，对应 OS thread|真正的线程|
|P|processor，运行 G 所需上下文（队列、缓存等）|非实体，是逻辑CPU|

当调度器要让某个 G 运行时会先保存当前 G 的寄存器 -> 切换到新 G 的寄存器 -> 切换到新 G 的 stack -> 开始执行。这个过程涉及以下两个核心函数。

* `gogo()`：执行 goroutine 栈切换 + 寄存器回复
* `mcall()`：从 G 切换到调度器（系统栈），执行调度逻辑

```
G -> mcall -> 调度器选择下一个 G -> gogo -> 新 G
```

## 上下文切换的真正内容

|内容|是否保存|
|:---|:---|
|G 的栈指针 SP|是|
|G 的程序计数器 PC|是|
|调用寄存器（ax、bx...）|是|
|调度器元信息（g.sched）|是|
|G 的 stack|否（栈本身不复制，只切换指针）|

Go 的上下文切换不切换整个线程栈，只切换 goroutine 的独立小栈。

与线程上下文切换的对比

|维度|G切换|线程切换|
|:---|:---|:---|
|切换方式|用户态，runtime汇编|内核态，系统调用|
|切换内容|少量寄存器 + 栈指针|全部寄存器 + 页表 + 内核栈|
|数量级|可创建百万G|一般几千个以内|
|切换栈|goroutine栈|线程栈|

