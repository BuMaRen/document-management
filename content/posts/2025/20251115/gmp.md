---
title: "Gmp"
date: 2025-11-15T23:32:28+08:00
description : "Go语言的GMP模型（摘自Go源码）"
tags: ["go", "goroutine", "thread", "processor", "scheduler"]
image : "/img/posts/2025/20251115/gmp.jpg"
---

# Go scheduler

Go 调度器的作用就是将已经准备好运行的 goroutine 分发给工作线程去执行。

涉及的几个主要的概念：  
* ``G`` - goroutine
* ``M`` - 工作线程
* ``P`` - processor（处理器），这是执行 Go 代码必要的资源

``M`` 必须绑定 ``P`` 才能执行 Go 代码，但在 ``M`` 被阻塞或进入系统调用（如read、write、网络IO）的时候可以没有绑定的 ``P``，更多详情可参考[设计文档](https://golang.org/s/go11sched)。

# 工作线程的停放和唤醒

这套机制需要在充分利用硬件的并行性能的同时停放多余 `M` 以防资源浪费。这存在两个难点。

## 调度器的状态是分布式的

每个 `P` 都有自己的运行队列，调度器无法感知各个 `P` 的队列中所有的 `G` 的数量。这样做的好处是可以减少锁的处理，实现高并发，缺点在于系统无法快速判断当前的 `M` 中是否有 `G` 进而停放对应的 `M`。

## 无法预测 goroutine 何时准备就绪

如果一个 `M` 刚被停放，马上就有新的 `G` 准备就绪了，这时候就要唤醒 `M`，这会引起上下文切换。因此调度器只能基于当前的信息做一个“足够好”的决策。

# 废弃的调度策略

有一些方案能工作，但是表现不佳。

## Centralize all scheduler state
    
集中统计 `G`/`M`/`P` 的状态。这个方案要求一把全局锁，所有的 `M` 都在竞争这把锁，会降低并发度。

## Direct goroutine handoff

当 `G` 准备就绪的时候，唤醒 `M` 并将 `G` 分发给它执行。这个机制下，当一个 `M` 中的 `G` 新建了另外一个 `G` 并且就绪了，那么会有一个新的 `M` 被唤醒，而原来的这个 `M` 可能很快就会因为没有工作而被停放。

## Unpark an additional thread

当 `G` 就绪且有空闲的 `P` 的时候唤醒额外的 `M` 但是并不将 `G` 提交给这个 `M` 处理，这种方法也可能导致 `M` 被反复地停放和唤醒。

# 当前采用的策略

go 提交任务的时如果有空闲的 `P`，且没有 `spinning` 的 `M`，那就会唤醒一个 `M`。

    一个 M 如果没有本地工作，没有在全局队列或网络轮询发现任务，那么这个 M 就会被认为处于 spinning 状态，这个状态在 runtime 中由 m.spinning 标记，并由 sched.nmspinning 统计。

这个方式唤醒的 `M` 会被标记为 `spinning`，且不将 `G` 提交给这个 `M`（前文描述的原因）。`spinning` 的 `M` 会在每个 `P` 的队列或定时器中寻找就绪的 `G`，还会查询一下 `GC`（如STW或协作点）。如果发现了可执行的工作，`M`会脱离 `spinning` 状态去执行这个任务，否则这个 `M` 会被停放。

提交任务的时候如果有 `spinning` 着的 `M` 就不会唤醒其他的 `M`，如果一个 `M` 脱离 `spinning` 开始工作，那就需要唤醒一个新的 `M`。

## 非全局队列中的任务处理

提交任务到全局队列总是会确保唤醒一个 `M`，除此之外的地方需要通过下列的流程来进行竞争态保护。

### 任务的提交模式

1. 提交任务到本地或全局队列、定时器堆、GC的待处理队列
2. #StoreLoad-style memory barrier.
    不执行 `nmspinning` 的检查
3. 检查 nmspinning

### non-spinning和spinning的状态转移

1. 减少 `nmspinning` 的计数
2. #StoreLoad-style memory barrier.
3. 寻找可以运行的任务

## 不同任务来源的区别

1. G 就绪
   当一个 `G` 被放入本地或者全局的运行队列的时候这个 `G` 就属于是就绪的。必须被安排到某个 `M` 上执行。
2. 定时器触发
   go 的 Timer 实现会在空闲的 `M` 上用 netpoll 等待最早的定时器触发。如果没有 `M` 在等待定时器触发就需要启动一个新的 `spinning` 的 `M` 去等待。
3. Idle-priority GC
   GC 可以唤醒已经停止（idle）的线程来做后台回收。

## M 状态的区别

|状态|CPU占用|唤醒方式|典型用途|备注|
|:---|:---|:---|:---|:---|
|spinning|占用CPU|继续循环检查队列|快速响应任务|高CPU小号，但latency最低|
|parked|不占用CPU|被unpark唤醒|一般线程池任务|需要保证lost wakeup<br>避免CPU underutilization|
|stoped idle|不占用CPU|GC/特定后台任务唤醒|后台GC/延迟工作|不随意唤醒，节省资源|

# 小结

当 `G` 被放入全局队列，调度器会唤醒 idle 的 `M`（没有则创建 `M`），如果没有空闲的 `P`，则 `M` 停放。不和本地队列竞争 CPU。

当有 `G` 本地队列后，如果有空闲的 `P` ，调度器会唤醒 `spinning` 的 `M`（没有则创建）来执行这个 `G`。唤醒的 `M` 会处于 `spinning` 状态，查询到任务后开始执行，并新建一个 `spinning` 的 `M`。

还有很多细节未理清，待补充...
